/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.5.3 public/dancer.glb -o src/react/rui/components/Dancer.tsx -t 
*/

import * as THREE from 'three';
import { JSX, useEffect, useMemo, useRef } from 'react';
import { useFrame, useGraph } from '@react-three/fiber';
import { useGLTF, useAnimations } from '@react-three/drei';
import { GLTF, SkeletonUtils } from 'three-stdlib';
import { useBox } from '@react-three/cannon';
import { Mesh } from 'three';
import { lerp } from 'three/src/math/MathUtils.js';

type ActionName =
  | 'breakdance01'
  | 'breakdancingEnd'
  | 'breakdanceFootworkToIdle'
  | 'uprock'
  | 'windmill'
  | 'wave'
  | 'hiphop01'
  | 'twerk'
  | 'hiphop02';

interface GLTFAction extends THREE.AnimationClip {
  name: ActionName;
}

type GLTFResult = GLTF & {
  nodes: {
    Ch03: THREE.SkinnedMesh;
    mixamorigHips: THREE.Bone;
  };
  materials: {
    Ch03_Body: THREE.MeshStandardMaterial;
  };
  animations: GLTFAction[];
};

export const ACTION_NAMES: ActionName[] = [
  'windmill',
  'wave',
  'breakdancingEnd',
  'breakdance01',
  'breakdanceFootworkToIdle',
  'uprock',
  'hiphop01',
  'twerk',
  'hiphop02',
];

interface Props {
  is_playing: boolean;
  action_idx: number;
  onDancerCollide?: () => void;
  group_props?: JSX.IntrinsicElements['group'];
}

export function Dancer({ is_playing, action_idx, onDancerCollide, group_props }: Props) {
  const group = useRef<THREE.Group>(null);
  const { scene, animations } = useGLTF('/dancer.glb');
  const clone = useMemo(() => SkeletonUtils.clone(scene), [scene]);
  const { nodes, materials } = useGraph(clone) as unknown as GLTFResult;
  const { actions } = useAnimations(animations, group);

  const [dancer_ref, dancer_api] = useBox<Mesh>(() => ({
    args: [3.4, 1, 3],
    type: 'Dynamic',
    onCollide: (e) => {
      const velocity = e.contact.impactVelocity;
      if (velocity < 4) {
        return;
      }
      onDancerCollide?.();
    },
  }));

  const values = useRef([0, 0]);
  useFrame((state) => {
    values.current[0] = lerp(values.current[0], (state.mouse.x * Math.PI) / 5, 0.2);
    values.current[1] = lerp(values.current[1], (state.mouse.x * Math.PI) / 5, 0.2);
    dancer_api.position.set(state.mouse.x * 10, state.mouse.y * 5, 0);
    dancer_api.rotation.set(0, 0, values.current[1]);
    if (!group.current) return;
    group.current.rotation.x = lerp(group.current.rotation.x, 0, 1);
    group.current.rotation.y = values.current[0];
  });

  useEffect(() => {
    if (!is_playing) {
      return;
    }
    const cur_animation = ACTION_NAMES[action_idx];
    actions[cur_animation]?.play();
    return () => {
      actions[cur_animation]?.stop();
    };
  }, [actions, action_idx, is_playing]);

  return (
    <mesh ref={dancer_ref} dispose={null}>
      <group ref={group} position={[0, 0, 0]} scale={0.02} {...group_props} dispose={null}>
        <group name='AuxScene'>
          <group position={[0, -82.942, -1.295]}>
            <primitive object={nodes.mixamorigHips} />
            <skinnedMesh
              name='Ch03'
              geometry={nodes.Ch03.geometry}
              material={materials.Ch03_Body}
              skeleton={nodes.Ch03.skeleton}
              castShadow
              receiveShadow
            />
          </group>
        </group>
      </group>
    </mesh>
  );
}

useGLTF.preload('/dancer.glb');
